// Generated by BUCKLESCRIPT VERSION 3.1.1, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Queue = require("bs-platform/lib/js/queue.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");

var resolvedPromise = Promise.resolve(/* () */0);

function enqueuePostPromiseJob(fn) {
  resolvedPromise.then((function () {
          setTimeout(fn, 1);
          return Promise.resolve(/* () */0);
        }));
  return /* () */0;
}

function firstNInQueueToArray(queue, numberOfValues) {
  var queueLength = Queue.length(queue);
  var match = queueLength > numberOfValues;
  var maxValues = match ? numberOfValues : queueLength;
  return $$Array.init(maxValues, (function () {
                return Queue.pop(queue);
              }));
}

function Make(Impl) {
  var shouldCache = Impl[/* options */1][/* cache */2];
  var shouldBatch = Impl[/* options */1][/* batch */0];
  var maxBatchSize = Impl[/* options */1][/* maxBatchSize */1];
  var batchLoadFun = Impl[/* batchLoadFun */0];
  var promiseCache = Hashtbl.create(/* None */0, 10);
  var queue = Queue.create(/* () */0);
  var clear = function (key) {
    return Hashtbl.remove(promiseCache, key);
  };
  var clearAll = function () {
    return Hashtbl.clear(promiseCache);
  };
  var prime = function (key, value) {
    if (Hashtbl.mem(promiseCache, key)) {
      return /* () */0;
    } else {
      return Hashtbl.add(promiseCache, key, Promise.resolve(value));
    }
  };
  var dispatchQueueBatch = function (queueSlice) {
    var keys = $$Array.map((function (param) {
            return param[0];
          }), queueSlice);
    Curry._1(batchLoadFun, keys).then((function (values) {
            $$Array.iteri((function (index, param) {
                    var match = Caml_array.caml_array_get(values, index);
                    if (match.tag) {
                      Hashtbl.remove(promiseCache, param[0]);
                      return param[2](match[0]);
                    } else {
                      return param[1](match[0]);
                    }
                  }), queueSlice);
            return Promise.resolve(/* () */0);
          }));
    return /* () */0;
  };
  var dispatchQueue = function (_param) {
    while(true) {
      if (Queue.is_empty(queue) === false) {
        dispatchQueueBatch(firstNInQueueToArray(queue, maxBatchSize));
        _param = /* () */0;
        continue ;
      } else {
        return /* () */0;
      }
    };
  };
  var addToQueue = function (item) {
    return Queue.push(item, queue);
  };
  var load = function (key) {
    if (shouldCache && Hashtbl.mem(promiseCache, key)) {
      return Hashtbl.find(promiseCache, key);
    } else {
      var promise = new Promise((function (resolve, reject) {
              Queue.push(/* tuple */[
                    key,
                    resolve,
                    reject
                  ], queue);
              if (Queue.length(queue) === 1) {
                if (shouldBatch) {
                  enqueuePostPromiseJob(dispatchQueue);
                } else {
                  dispatchQueue(/* () */0);
                }
                return /* () */0;
              } else {
                return dispatchQueue(/* () */0);
              }
            }));
      if (shouldCache) {
        Hashtbl.add(promiseCache, key, promise);
        return promise;
      } else {
        return promise;
      }
    }
  };
  var loadMany = function (keys) {
    return Promise.all($$Array.map(load, keys));
  };
  return /* module */[
          /* shouldCache */shouldCache,
          /* shouldBatch */shouldBatch,
          /* maxBatchSize */maxBatchSize,
          /* batchLoadFun */batchLoadFun,
          /* promiseCache */promiseCache,
          /* queue */queue,
          /* clear */clear,
          /* clearAll */clearAll,
          /* prime */prime,
          /* dispatchQueueBatch */dispatchQueueBatch,
          /* dispatchQueue */dispatchQueue,
          /* addToQueue */addToQueue,
          /* load */load,
          /* loadMany */loadMany
        ];
}

exports.resolvedPromise = resolvedPromise;
exports.enqueuePostPromiseJob = enqueuePostPromiseJob;
exports.firstNInQueueToArray = firstNInQueueToArray;
exports.Make = Make;
/* resolvedPromise Not a pure module */
